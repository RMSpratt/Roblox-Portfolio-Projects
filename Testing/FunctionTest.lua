export type CompareInfo = {
    ComparisonMethod: string,
    ComparisonKeyTable: table?,
    ComparisonFunction: (any, any) -> boolean
}
export type ReturnValue = {
    ExpectedType: string,
    ExpectedValue: any,
    ComparisonInfo: CompareInfo
}

export type ParamMutation = {
    ParamIdx: number,
    ParamType: string,
    ExpectedValue: any,
    ComparisonInfo: CompareInfo
}

local UnitTest = {
    MutationComparisonMethods = {
        Direct = "Direct",          --Comapre the actual and expected parameter values directly (==)
        KeyTable = "KeyTable",      --Compare the actual and expected parameter values by keys
        Function = "Function"       --Compare the actual and expected parameter values by function
    },
}

---Creates a template error message for an uncaptured error generated by a test function.
---@param errMsg string
---@param testContext string
---@param testNum number
---@return string
local function _logFailureErrorThrown(errMsg: string, testContext: string, testNum: number)
    return `{testContext} - {testNum} ERR_THROWN: {errMsg}`
end

---Creates a template error message for a variable ClassName mismatch.
---@param expectedClassName string
---@param actualClassName string
---@param testContext string
---@param testNum number
local function _logFailureUnexpectedClassName(expectedClassName: string, actualClassName: string, testContext: string, testNum: number)
    return `{testContext} - {testNum} BAD_CLASS_NAME: Expected - {expectedClassName} Actual - {actualClassName}`
end

---Creates a template error message for a variable type mismatch.
---@param expectedType string
---@param actualType string
---@param testContext string
---@param testNum number
---@return string
local function _logFailureUnexpectedType(expectedType: string, actualType: string, testContext: string, testNum: number)
    return `{testContext} - {testNum} BAD_TYPE: Expected - {expectedType} Actual - {actualType}`
end

---Creates a template error message for a variable value mismatch.
---@param expectedValue any
---@param actualValue any
---@param testContext string
---@param testNum number
---@return string
local function _logFailureUnexpectedValue(expectedValue: any, actualValue: any, testContext: string, testNum: number)
    return `{testContext} - {testNum} BAD_VALUE: Expected - {expectedValue} Actual - {actualValue}`
end

---Creates a template error message for a variable value mismatch by key value.
---@param expectedKeyName string
---@param expectedKeyValue any
---@param actualKeyValue any
---@param testContext string
---@param testNum number
---@return any
local function _logFailureUnexpectedValueKeyValue(expectedKeyName: string, expectedKeyValue: any, actualKeyValue: any, testContext: string, testNum: number)
    return `{testContext} - {testNum} BAD_VALUE_KEY: Expected Key {expectedKeyName} Value - {expectedKeyValue} Actual - {actualKeyValue}`
end

---Utility function to compare two values. See CompareInfo about the possible methods available.
---@param expectedValue any
---@param actualValue any
---@param comparisonInfo table
---@param unitContext string
---@param testNum number
---@return boolean
---@return string
local function compareExpectedValue(expectedValue: any, actualValue: any, comparisonInfo: CompareInfo, unitContext: string, testNum: number)
    local matchesValue = true
    local matchViolation = nil

    if not comparisonInfo then
        comparisonInfo = {ComparisonMethod = UnitTest.MutationComparisonMethods.Direct}
    end

    if comparisonInfo.ComparisonMethod == UnitTest.MutationComparisonMethods.Function then

        if not comparisonInfo.ComparisonFunction(expectedValue, actualValue) then
            matchesValue = false
            matchViolation = _logFailureUnexpectedValue(
                expectedValue, actualValue, unitContext, testNum)
        end

    elseif comparisonInfo.ComparisonMethod == UnitTest.MutationComparisonMethods.KeyTable then
        local didKeyCheckPass = true

        for expectedKeyName, expectedKeyValue in comparisonInfo.ComparisonKeyTable do

            if not actualValue[expectedKeyName] or actualValue[expectedKeyName] ~= expectedKeyValue then
                didKeyCheckPass = false
                matchViolation = _logFailureUnexpectedValueKeyValue(
                    expectedKeyName, expectedValue, actualValue, unitContext, testNum)
            end
        end

        if not didKeyCheckPass then
            matchesValue = false
        end

    else

        if actualValue ~= expectedValue then
            matchesValue = false
            matchViolation = _logFailureUnexpectedValue(
                expectedValue, actualValue, unitContext, testNum)
        end
    end

    return matchesValue, matchViolation
end


local UnitTestFuncs = {
    ClassNames = {
        BasePart = "BasePart",
        Folder = "Folder",
        Model = "Model",
    },

    MutationComparisonMethods = UnitTest.MutationComparisonMethods,

    Types = {
        Function = "Function",
        Nil = "Nil",
        Number = "Number",
        Instance = "Instance",
        String = "String",
        Table = "Table",
        Vector2 = "Vector2",
        Vector3 = "Vector3"
    },
}

---Runs a function with expected input mutations and checks if the parameters are modified as expected.
--Mutations specified must be for a mutable type
---@param funcToCall function The function to invoke
---@param inputs table The inputs (parameters) to the testing function
---@param expectedMutations table A list of ParamMutation descriptions for the given inputs
---@param testContext string
---@param testNum number
---@return boolean
---@return string
function UnitTestFuncs.RunFunctionMutationTest(funcToCall: (any) -> {}, inputs: table, expectedMutations: table, testContext: string, testNum: number)
    local didTestPass = true
    local testViolation = nil

    testContext = testContext or "Testing"
    testNum = testNum or 1

    funcToCall(table.unpack(inputs))

    for _, mutationInfo: ParamMutation in expectedMutations do
        local paramValue = inputs[mutationInfo.ParamIdx]

        --The actual parameter value must have the same basic type as the expected value
        if mutationInfo.ParamType == typeof(paramValue) then
            didTestPass, testViolation = compareExpectedValue(
                mutationInfo.ExpectedValue, paramValue, mutationInfo.ComparisonInfo, testContext, testNum)

            if not didTestPass then
                break
            end

        else
            didTestPass = false
            testViolation = _logFailureUnexpectedType(
                mutationInfo.ExpectedValue, paramValue, testContext, testNum)
            break
        end
    end

    return didTestPass, testViolation
end

---Runs a function with 0+ expected return values, and checks if the actual output matches that expected.
---@param funcToCall function
---@param funcParams table
---@param expectedReturnInfoList table
---@param testContext string
---@param testNum number The test id or index.
---@return boolean
---@return string
function UnitTestFuncs.RunFunctionReturnTest(funcToCall: (any) -> {}, funcParams: table, expectedReturnInfoList: table, testContext: string, testNum: number)
    local didTestPass = true
    local testViolation = nil

    testContext = testContext or "Testing"
    testNum = testNum or 1

    local returnValues = table.pack(funcToCall(table.unpack(funcParams)))

    for returnValueIdx, returnValue in ipairs(returnValues) do
        local expectedReturnInfo: ReturnValue = expectedReturnInfoList[returnValueIdx]
        local returnValueType = typeof(returnValue)

        if returnValueType == expectedReturnInfo.ExpectedType then

            if not expectedReturnInfo.ExpectedClassName or
                expectedReturnInfo.ExpectedClassName == returnValue.ClassName then

                didTestPass, testViolation = compareExpectedValue(
                    expectedReturnInfo.ExpectedValue,
                    returnValue,
                    expectedReturnInfo.ComparisonInfo,
                    testContext,
                    testNum)

                if not didTestPass then
                    break
                end

            else
                testViolation =_logFailureUnexpectedClassName(
                    expectedReturnInfoList[returnValueIdx].ExpectedClassName,
                    returnValue.ClassName,
                    testContext,
                    testNum)

                didTestPass = false
                break
            end

        else
            testViolation =_logFailureUnexpectedType(
                expectedReturnInfoList[returnValueIdx].ExpectedType,
                returnValueType,
                testContext,
                testNum)

            didTestPass = false
            break
        end
    end

    return didTestPass, testViolation
end

---Runs a function with expected input mutations and checks if the parameters are modified as expected.
--xpcall is used to catch uncaught errors.
---@param funcToCall function The function to invoke
---@param inputs table The inputs (parameters) to the testing function
---@param expectedMutations table A list of ParamMutation descriptions for the given inputs
---@param unitContext string
---@param testNum number
---@return boolean
---@return string
function UnitTestFuncs.RunFunctionMutationTestSafe(funcToCall: (any) -> {}, inputs: table, expectedMutations: table, unitContext: string, testNum: number)
    local runError = nil

    unitContext = unitContext or "Testing"
    testNum = testNum or 1

    local runSuccess, testSuccess, testViolation = xpcall(
        function()
            return UnitTestFuncs.RunFunctionMutationTest(
                funcToCall, table.unpack(inputs), expectedMutations, unitContext, testNum)
        end,
        function(errMsg)
            runError = tostring(errMsg)
        end)

    if not runSuccess then
        testSuccess = false
        testViolation = _logFailureErrorThrown(runError, unitContext, testNum)
    end

    return testSuccess, testViolation
end

---Runs a function with 0+ expected return values, and checks if the actual output matches that expected.
---The function is run using xpcall in-case of error.
---@param funcToCall function The function to call.
---@param inputs table Inputs to the function to call.
---@param expectedReturnInfo table The expected ouput information.
---@param unitContext string The testing context.
---@param testNum number The test id or index.
---@return boolean
---@return string
function UnitTestFuncs.RunFunctionReturnTestSafe(funcToCall: (any) -> {}, inputs: table, expectedReturnInfo: table, unitContext: string, testNum: number)
    local runError = nil

    unitContext = unitContext or "Testing"
    testNum = testNum or 1

    local runSuccess, testSuccess, testViolation = xpcall(
        function()
            return UnitTestFuncs.RunFunctionReturnTest(
                funcToCall, table.unpack(inputs), expectedReturnInfo, unitContext, testNum)
        end,

        function(errMsg)
            runError = tostring(errMsg)
        end)

    if not runSuccess then
        testSuccess = false
        testViolation = _logFailureErrorThrown(runError, unitContext, testNum)
    end

    return testSuccess, testViolation
end

return UnitTestFuncs